<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>升降工作台控制系统</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#165DFF',
            dark: '#1D2939',
            neutral: '#667085',
          },
        },
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .control-btn {
        @apply w-10 h-10 rounded-lg bg-dark text-white text-sm font-bold 
               flex items-center justify-center cursor-pointer transition-all 
               duration-200 hover:bg-primary active:scale-95 flex-shrink-0
               touch-manipulation select-none;
      }
      .display-panel {
        @apply bg-dark text-[#00FF9D] rounded-lg p-2 font-mono text-lg 
               shadow-inner flex items-center justify-center w-20 flex-shrink-0;
      }
      .control-bar {
        @apply flex flex-wrap items-center gap-1.5 w-full;
        padding-bottom: 4px;
      }
      .control-buttons-group {
        @apply flex items-center gap-1.5;
      }
      .workbench-container {
        @apply relative h-[28vh] min-h-[210px] w-full mb-4 overflow-hidden border border-gray-200 rounded-lg;
      }
      .ruler-wrapper {
        @apply absolute left-0 top-0 h-full w-16 border-r border-gray-200;
      }
      .ruler-mark-container {
        @apply absolute left-0 top-0 h-full w-full pr-1;
      }
      .ruler-mark {
        @apply absolute w-full flex items-center justify-end;
        margin: 0;
        padding: 0;
      }
      .ruler-number {
        @apply w-5 text-right pr-1 text-xs font-medium text-gray-700;
        line-height: 1;
      }
      .ruler-line-container {
        @apply flex items-center;
      }
      .ruler-main {
        @apply h-[2px] bg-gray-700 w-6;
      }
      .ruler-sub {
        @apply h-[2px] bg-gray-500 w-4;
      }
      .workbench-area {
        @apply absolute left-16 right-0 top-0 bottom-0;
      }
      .workbench-leg {
        @apply absolute w-6 bg-gray-400;
      }
      .workbench-top {
        @apply absolute h-6 bg-primary rounded-t-md flex items-center justify-center text-white text-xs font-bold;
      }
      .height-arrow {
        @apply absolute left-[4px] w-0 h-0 transform -translate-y-1/2;
        border-top: 4px solid transparent;
        border-bottom: 4px solid transparent;
        border-right: 6px solid green;
      }
      .limit-arrow {
        @apply absolute left-[67px] w-0 h-0 transform -translate-y-1/2;
        border-top: 4px solid transparent;
        border-bottom: 4px solid transparent;
        border-right: 6px solid red;
        z-index: 10;
      }
      .button-spacer {
        @apply h-6 w-full;
      }
      .bottom-reserve {
        @apply min-h-[120px] w-full;
      }
      /* 触摸反馈样式 */
      .touch-active {
        @apply scale-95 bg-primary;
      }
      .long-press-progress {
        @apply absolute inset-0 rounded-lg bg-primary opacity-0 transition-opacity duration-1000;
      }
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-start p-3 touch-manipulation select-none">
  <div class="w-full max-w-md bg-white rounded-xl shadow-lg p-4">
    <!-- 标题区域 -->
    <div class="text-center bg-primary text-white p-3 rounded-lg mb-4">
      <h1 class="text-lg font-bold">升降工作台控制系统</h1>
      <p class="text-sm text-blue-100">高度范围: 65~120CM</p>
    </div>
    
    <!-- 工作台显示区域 -->
    <div class="workbench-container">
      <div class="ruler-wrapper">
        <div class="ruler-mark-container" id="ruler-mark-container"></div>
      </div>
      
      <div class="workbench-area">
        <div id="leg-left" class="workbench-leg" style="left: 20%; bottom: 0;"></div>
        <div id="leg-right" class="workbench-leg" style="right: 20%; bottom: 0;"></div>
        <div id="workbench" class="workbench-top" style="left: 15%; width: 70%;">台面</div>
        <div id="height-arrow" class="height-arrow"></div>
      </div>
    </div>
    
    <!-- 控制栏 -->
    <div class="control-bar">
      <div class="display-panel">
        <span id="height-display">100.0</span>
        <span class="ml-1 text-sm">CM</span>
      </div>
      
      <div class="control-buttons-group">
        <div class="control-btn" id="btn-up" data-btn="up">
          <i class="fa fa-chevron-up"></i>
        </div>
        <div class="control-btn" id="btn-down" data-btn="down">
          <i class="fa fa-chevron-down"></i>
        </div>
        
        <div class="control-btn" data-btn="1">1</div>
        <div class="control-btn" data-btn="2">2</div>
        <div class="control-btn" data-btn="3">3</div>
        <div class="control-btn" data-btn="4">4</div>
        
        <div class="control-btn bg-neutral relative" data-btn="M" id="btn-m">
          M
          <div class="long-press-progress" id="long-press-progress"></div>
        </div>
      </div>
    </div>
    
    <div class="button-spacer"></div>
    
    <!-- 操作说明 -->
    <div class="text-xs text-gray-600 bg-gray-50 p-3 rounded-lg">
      <p class="font-medium mb-1">操作说明：</p>
      <ul class="list-disc list-inside space-y-0.5">
        <li>↑：工作台上升</li>
        <li>↓：工作台下降</li>
        <li>M键：进入/退出设置</li>
        <li>设置+数字键：保存高度</li>
        <li>设置+↑/↓+长按M：设限位</li>
        <li>设置+长按M：恢复限位初始值</li>
        <li>长按↓键5秒：进入复位模式</li>
        <li>复位模式+↓键：退出复位模式</li>
        <li>复位模式+长按2键5秒：切换单位(cm/inch)</li>
      </ul>
    </div>
    
    <div class="bottom-reserve"></div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // 核心参数
      const minorStep = 2;                  
      const majorStep = 10;                 
      const majorLines = [130, 120, 110, 100, 90, 80, 70, 60]; 
      const displayNumbers = [120, 110, 100, 90, 80, 70, 65];  
      const defaultMinHeight = 65.0;        
      const defaultMaxHeight = 120.0;       
      const adjustMajorLines = [120, 110, 100, 90, 80, 70];    
      
      let upperLimit = defaultMaxHeight;    
      let lowerLimit = defaultMinHeight;    
      
      const totalHeightRange = majorLines[0] - majorLines[majorLines.length - 1];
      const totalMinorTicks = totalHeightRange / minorStep;
      
      // DOM元素
      const heightArrow = document.getElementById('height-arrow');
      const workbench = document.getElementById('workbench');
      const legLeft = document.getElementById('leg-left');
      const legRight = document.getElementById('leg-right');
      const heightDisplay = document.getElementById('height-display');
      const displayUnit = heightDisplay.nextElementSibling;
      const rulerContainer = document.getElementById('ruler-mark-container');
      const btnUp = document.getElementById('btn-up');
      const btnDown = document.getElementById('btn-down');
      const btnSet = document.getElementById('btn-m');
      const longPressProgress = document.getElementById('long-press-progress');
      const buttons = document.querySelectorAll('[data-btn]');
      
      const savedHeights = {1: null, 2: null, 3: null, 4: null};
      let upperLimitArrow = null;
      let lowerLimitArrow = null;
      
      // 状态变量
      let isMoving = false;
      let movementInterval = null;
      let isSetting = false;
      let isLongPressing = false; 
      let lastDirection = null;
      let longPressTimer = null;
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartTime = 0;
      let isTouchDevice = false;
      let isResetMode = false;
      let isCmUnit = true; // true: cm, false: inch
      let downKeyLongPressTimer = null;
      let key2LongPressTimer = null;
      
      // 检测设备类型
      function detectDeviceType() {
        isTouchDevice = 'ontouchstart' in window || 
                       navigator.maxTouchPoints > 0 || 
                       navigator.msMaxTouchPoints > 0;
        return isTouchDevice;
      }
      
      // 核心计算函数
      function calculatePosition(height) {
        const rulerHeight = rulerContainer.offsetHeight;
        const availableHeight = rulerHeight * 0.8;
        const tickHeight = availableHeight / totalMinorTicks;
        
        const baseTopPos = rulerHeight * 0.1 + ((majorLines[0] - height) / minorStep) * tickHeight;
        if (adjustMajorLines.includes(height)) {
          return baseTopPos - tickHeight;
        }
        return baseTopPos;
      }
      
      function generateRuler() {
        rulerContainer.innerHTML = '';
        
        for (let h of majorLines) {
          const topPos = calculatePosition(h);
          const mark = createMark(h, topPos, true);
          rulerContainer.appendChild(mark);
        }
        
        for (let h = majorLines[0]; h >= majorLines[majorLines.length - 1]; h -= minorStep) {
          if (majorLines.includes(h)) continue;
          const topPos = calculatePosition(h);
          const mark = createMark(h, topPos, false);
          rulerContainer.appendChild(mark);
        }
        
        updateLimitArrows();
      }
      
      function createMark(height, topPos, isMajor) {
        const mark = document.createElement('div');
        mark.className = 'ruler-mark';
        mark.style.top = `${parseFloat(topPos.toFixed(2))}px`;
        
        const number = document.createElement('div');
        number.className = 'ruler-number';
        number.textContent = displayNumbers.includes(height) ? height : '';
        mark.appendChild(number);
        
        const lineContainer = document.createElement('div');
        lineContainer.className = 'ruler-line-container';
        
        const line = document.createElement('div');
        line.className = isMajor ? 'ruler-main' : 'ruler-sub';
        lineContainer.appendChild(line);
        
        mark.appendChild(lineContainer);
        return mark;
      }
      
      function pixelToHeight(pixel) {
        const rulerHeight = rulerContainer.offsetHeight;
        const availableHeight = rulerHeight * 0.8;
        const tickHeight = availableHeight / totalMinorTicks;
        
        const ticksFromTop = (pixel - rulerHeight * 0.1) / tickHeight;
        const height = majorLines[0] - (ticksFromTop * minorStep);
        return Math.max(lowerLimit, Math.min(upperLimit, Math.round(height * 10) / 10));
      }
      
      function updateAllElements() {
        const container = document.querySelector('.workbench-container');
        const containerHeight = container.offsetHeight;
        
        const arrowTop = parseFloat(heightArrow.style.top) || calculatePosition(100.0);
        const currentHeight = pixelToHeight(arrowTop);
        
        if (isResetMode) {
          heightDisplay.textContent = 'RST';
          displayUnit.textContent = '';
        } else if (isSetting) {
          heightDisplay.textContent = 'S -';
          displayUnit.textContent = '';
        } else {
          if (isCmUnit) {
            heightDisplay.textContent = currentHeight.toFixed(1);
            displayUnit.textContent = 'CM';
          } else {
            const inchHeight = currentHeight * 0.393701;
            heightDisplay.textContent = inchHeight.toFixed(1);
            displayUnit.textContent = 'IN';
          }
        }
        
        workbench.style.top = `${arrowTop}px`;
        const legHeight = containerHeight - arrowTop - 6;
        legLeft.style.height = `${Math.max(0, legHeight)}px`;
        legRight.style.height = `${Math.max(0, legHeight)}px`;
      }
      
      function moveArrow(direction) {
        if (isMoving || isSetting) return;
        isMoving = true;
        
        const rulerHeight = rulerContainer.offsetHeight;
        const availableHeight = rulerHeight * 0.8;
        const tickHeight = availableHeight / totalMinorTicks;
        const step = tickHeight / 10;
        
        const maxPixel = calculatePosition(upperLimit);
        const minPixel = calculatePosition(lowerLimit);
        
        movementInterval = setInterval(() => {
          let currentTop = parseFloat(heightArrow.style.top) || calculatePosition(100.0);
          
          if (direction === 'up') {
            currentTop = Math.max(maxPixel, currentTop - step);
          } else {
            currentTop = Math.min(minPixel, currentTop + step);
          }
          
          heightArrow.style.top = `${currentTop}px`;
          updateAllElements();
        }, 20);
      }
      
      function stopMovingArrow() {
        clearInterval(movementInterval);
        isMoving = false;
      }
      
      function moveToTarget(target) {
        if (isMoving || !target || isSetting) return;
        const validTarget = Math.max(lowerLimit, Math.min(upperLimit, target));
        isMoving = true;
        
        const targetPixel = calculatePosition(validTarget);
        const step = (targetPixel - (parseFloat(heightArrow.style.top) || calculatePosition(100.0))) / 50;
        
        movementInterval = setInterval(() => {
          const currentTop = parseFloat(heightArrow.style.top) || calculatePosition(100.0);
          let newTop = currentTop < targetPixel ? 
            Math.min(targetPixel, currentTop + Math.abs(step)) : 
            Math.max(targetPixel, currentTop - Math.abs(step));
          
          heightArrow.style.top = `${newTop}px`;
          updateAllElements();
          
          if (Math.abs(newTop - targetPixel) < 0.5) {
            heightArrow.style.top = `${targetPixel}px`;
            updateAllElements();
            stopMovingArrow();
          }
        }, 20);
      }
      
      function flashDisplay() {
        if (!isSetting) return;
        const originalText = heightDisplay.textContent;
        heightDisplay.textContent = '';
        setTimeout(() => {
          if (isSetting) heightDisplay.textContent = originalText;
        }, 200);
      }
      
      function updateLimitArrows() {
        if (upperLimitArrow) upperLimitArrow.remove();
        if (lowerLimitArrow) lowerLimitArrow.remove();
        
        upperLimitArrow = document.createElement('div');
        upperLimitArrow.className = 'limit-arrow';
        upperLimitArrow.style.top = `${calculatePosition(upperLimit)}px`;
        rulerContainer.appendChild(upperLimitArrow);
        
        lowerLimitArrow = document.createElement('div');
        lowerLimitArrow.className = 'limit-arrow';
        lowerLimitArrow.style.top = `${calculatePosition(lowerLimit)}px`;
        rulerContainer.appendChild(lowerLimitArrow);
      }
      
      function setUpperLimit() {
        const currentHeight = pixelToHeight(parseFloat(heightArrow.style.top) || calculatePosition(100.0));
        upperLimit = currentHeight;
        heightDisplay.textContent = '999';
        displayUnit.textContent = '';
        setTimeout(() => {
          isSetting = false;
          updateAllElements();
          updateLimitArrows();
        }, 1000);
      }
      
      function setLowerLimit() {
        const currentHeight = pixelToHeight(parseFloat(heightArrow.style.top) || calculatePosition(100.0));
        lowerLimit = currentHeight;
        heightDisplay.textContent = '000';
        displayUnit.textContent = '';
        setTimeout(() => {
          isSetting = false;
          updateAllElements();
          updateLimitArrows();
        }, 1000);
      }
      
      function resetLimitsToDefault() {
        // 恢复限位初始值
        upperLimit = defaultMaxHeight;
        lowerLimit = defaultMinHeight;
        
        // 显示"555"
        heightDisplay.textContent = '555';
        displayUnit.textContent = '';
        
        // 1秒后退出设置模式
        setTimeout(() => {
          isSetting = false;
          updateAllElements();
          updateLimitArrows();
        }, 1000);
      }
      
      // 长按逻辑
      function startLongPress() {
        if (isSetting && !isMoving) {
          isLongPressing = true;
          // 显示长按进度指示器
          if (longPressProgress) {
            longPressProgress.style.opacity = '0';
            // 根据设备类型设置不同的过渡时间
            const transitionDuration = isTouchDevice ? '1500ms' : '2000ms';
            longPressProgress.style.transition = `opacity ${transitionDuration}`;
            setTimeout(() => {
              if (isLongPressing) {
                longPressProgress.style.opacity = '0.5';
              }
            }, 10);
          }
          
          // 根据设备类型设置不同的长按检测时间
          const delay = isTouchDevice ? 1500 : 2000;
          longPressTimer = setTimeout(() => {
            if (isLongPressing && isSetting) {
              // 检查是否有选择方向（上或下）
              if (lastDirection === 'up') {
                setUpperLimit();
              } else if (lastDirection === 'down') {
                setLowerLimit();
              } else {
                // 如果没有选择方向，则恢复限位初始值
                resetLimitsToDefault();
              }
            }
          }, delay);
        }
      }
      
      function endLongPress() {
        isLongPressing = false;
        clearTimeout(longPressTimer);
        // 隐藏长按进度指示器
        if (longPressProgress) {
          longPressProgress.style.opacity = '0';
        }
      }
      
      // 触摸反馈
      function addTouchFeedback(element) {
        element.classList.add('touch-active');
        setTimeout(() => {
          element.classList.remove('touch-active');
        }, 200);
      }
      
      // 处理触摸事件
      function handleTouchStart(e, callback) {
        // 阻止默认行为以防止滚动和缩放
        e.preventDefault();
        
        // 记录触摸起始位置和时间
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
        
        // 添加触摸反馈
        const target = e.currentTarget;
        addTouchFeedback(target);
        
        // 执行回调
        if (callback) callback();
      }
      
      function handleTouchEnd(e, startCallback, endCallback) {
        // 阻止默认行为
        e.preventDefault();
        
        // 计算触摸持续时间
        const touchDuration = Date.now() - touchStartTime;
        
        // 执行结束回调
        if (endCallback) endCallback();
        
        // 如果触摸时间很短，可能是误触，不执行操作
        if (touchDuration < 50) return;
        
        // 计算触摸移动距离
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const deltaX = Math.abs(touchEndX - touchStartX);
        const deltaY = Math.abs(touchEndY - touchStartY);
        
        // 如果移动距离很小，视为点击
        if (deltaX < 10 && deltaY < 10) {
          // 模拟点击事件
          e.currentTarget.click();
        }
      }
      
      function bindEvents() {
        // 检测设备类型
        detectDeviceType();
        
        // 上下键事件处理
        const handleUpStart = () => {
          if (isResetMode) {
            // 在复位模式下，上键无效
            return;
          }
          
          if (isSetting) {
            lastDirection = 'up';
            flashDisplay();
          } else {
            moveArrow('up');
          }
        };
        
        const handleDownStart = () => {
          if (isResetMode) {
            // 在复位模式下，按下键退出复位模式
            isResetMode = false;
            updateAllElements();
            return;
          }
          
          if (isSetting) {
            lastDirection = 'down';
            flashDisplay();
          } else {
            moveArrow('down');
          }
        };
        
        // 处理下键长按进入复位模式
        const handleDownLongPressStart = () => {
          if (isResetMode || isSetting) return;
          
          // 记录长按开始时间
          const pressStartTime = Date.now();
          
          // 使用interval而不是timeout，以便在长按过程中检测是否超过5秒
          downKeyLongPressTimer = setInterval(() => {
            // 如果已经进入复位模式或设置模式，停止检测
            if (isResetMode || isSetting) {
              clearInterval(downKeyLongPressTimer);
              return;
            }
            
            // 如果长按时间超过5秒，进入复位模式
            if (Date.now() - pressStartTime >= 5000) {
              isResetMode = true;
              // 如果工作台正在移动，停止移动
              if (isMoving) {
                stopMovingArrow();
              }
              updateAllElements();
              clearInterval(downKeyLongPressTimer);
            }
          }, 100); // 每100毫秒检查一次
        };
        
        const handleDownLongPressEnd = () => {
          clearInterval(downKeyLongPressTimer);
        };
        
        const handleMoveEnd = () => stopMovingArrow();
        
        // 上下键 - 鼠标事件
        btnUp.addEventListener('mousedown', handleUpStart);
        btnUp.addEventListener('mouseup', handleMoveEnd);
        btnUp.addEventListener('mouseleave', handleMoveEnd);
        
        btnDown.addEventListener('mousedown', (e) => {
          handleDownStart(e);
          handleDownLongPressStart();
        });
        btnDown.addEventListener('mouseup', (e) => {
          handleMoveEnd(e);
          handleDownLongPressEnd();
        });
        btnDown.addEventListener('mouseleave', (e) => {
          handleMoveEnd(e);
          handleDownLongPressEnd();
        });
        
        // 上下键 - 触摸事件
        btnUp.addEventListener('touchstart', (e) => {
          handleTouchStart(e, handleUpStart);
        }, { passive: false });
        
        btnUp.addEventListener('touchend', (e) => {
          handleTouchEnd(e, null, handleMoveEnd);
        }, { passive: false });
        
        btnUp.addEventListener('touchcancel', (e) => {
          handleMoveEnd();
        }, { passive: false });
        
        btnDown.addEventListener('touchstart', (e) => {
          handleTouchStart(e, () => {
            handleDownStart();
            handleDownLongPressStart();
          });
        }, { passive: false });
        
        btnDown.addEventListener('touchend', (e) => {
          handleTouchEnd(e, null, () => {
            handleMoveEnd();
            handleDownLongPressEnd();
          });
        }, { passive: false });
        
        btnDown.addEventListener('touchcancel', (e) => {
          handleMoveEnd();
          handleDownLongPressEnd();
        }, { passive: false });
        
        // M键 - 单击切换设置
        btnSet.addEventListener('click', () => {
          if (isMoving) return;
          isSetting = !isSetting;
          // 每次进入设置模式时重置lastDirection
          if (isSetting) {
            lastDirection = null;
          }
          updateAllElements();
        });
        
        // M键 - 长按处理
        btnSet.addEventListener('mousedown', (e) => {
          e.preventDefault();
          startLongPress();
        });
        
        btnSet.addEventListener('mouseup', (e) => {
          e.preventDefault();
          endLongPress();
        });
        
        btnSet.addEventListener('mouseleave', (e) => {
          endLongPress();
        });
        
        // M键 - 触摸事件
        btnSet.addEventListener('touchstart', (e) => {
          handleTouchStart(e, startLongPress);
        }, { passive: false });
        
        btnSet.addEventListener('touchend', (e) => {
          handleTouchEnd(e, null, endLongPress);
        }, { passive: false });
        
        btnSet.addEventListener('touchcancel', (e) => {
          endLongPress();
        }, { passive: false });
        
        // 数字键事件
        buttons.forEach(btn => {
          const key = btn.dataset.btn;
          if (['1','2','3','4'].includes(key)) {
            // 鼠标点击
            btn.addEventListener('click', (e) => handleNumberKey(e, btn));
            
            // 触摸点击
            btn.addEventListener('touchstart', (e) => {
              handleTouchStart(e);
              
              // 处理2键长按切换单位
              if (key === '2' && isResetMode) {
                key2LongPressTimer = setTimeout(() => {
                  toggleUnit();
                }, 5000);
              }
            }, { passive: false });
            
            btn.addEventListener('touchend', (e) => {
              handleTouchEnd(e, null, () => {
                // 触摸结束时触发点击
                handleNumberKey({currentTarget: btn}, btn);
              });
              
              // 清除长按计时器
              if (key === '2') {
                clearTimeout(key2LongPressTimer);
              }
            }, { passive: false });
            
            // 鼠标长按处理
            btn.addEventListener('mousedown', (e) => {
              if (key === '2' && isResetMode) {
                key2LongPressTimer = setTimeout(() => {
                  toggleUnit();
                }, 5000);
              }
            });
            
            btn.addEventListener('mouseup', (e) => {
              if (key === '2') {
                clearTimeout(key2LongPressTimer);
              }
            });
            
            btn.addEventListener('mouseleave', (e) => {
              if (key === '2') {
                clearTimeout(key2LongPressTimer);
              }
            });
          }
        });
        
        function handleNumberKey(e, btn) {
          if (isMoving || isResetMode) return;
          
          const key = btn.dataset.btn;
          const currentHeight = pixelToHeight(
            parseFloat(heightArrow.style.top) || calculatePosition(100.0)
          );
          
          if (isSetting) {
            savedHeights[key] = currentHeight;
            btn.classList.add('bg-green-600');
            setTimeout(() => btn.classList.remove('bg-green-600'), 500);
            isSetting = false;
            updateAllElements();
          } else if (savedHeights[key] !== null) {
            moveToTarget(savedHeights[key]);
          }
        }
        
        // 切换单位函数
        function toggleUnit() {
          if (!isResetMode) return;
          
          const currentHeight = pixelToHeight(
            parseFloat(heightArrow.style.top) || calculatePosition(100.0)
          );
          
          // 切换单位
          isCmUnit = !isCmUnit;
          
          // 显示固定值
          if (isCmUnit) {
            // 从inch切换到cm
            heightDisplay.textContent = '10.3';
            displayUnit.textContent = 'CM';
          } else {
            // 从cm切换到inch
            heightDisplay.textContent = '10.4';
            displayUnit.textContent = 'IN';
          }
          
          // 1秒后恢复显示当前高度的换算值
          setTimeout(() => {
            updateAllElements();
          }, 1000);
        }
        
        // 防止页面滚动
        document.addEventListener('touchmove', (e) => {
          e.preventDefault();
        }, { passive: false });
      }
      
      // 初始化
      function init() {
        if (rulerContainer.offsetHeight > 0) {
          generateRuler();
          heightArrow.style.top = `${calculatePosition(100.0)}px`;
          updateAllElements();
          updateLimitArrows();
          bindEvents();
        } else {
          setTimeout(init, 50);
        }
      }
      
      init();
      window.addEventListener('resize', () => {
        const currentHeight = pixelToHeight(
          parseFloat(heightArrow.style.top) || calculatePosition(100.0)
        );
        
        generateRuler();
        heightArrow.style.top = `${calculatePosition(currentHeight)}px`;
        updateAllElements();
      });
    });
  </script>
</body>
</html>
